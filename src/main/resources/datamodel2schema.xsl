<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xalan="http://xml.apache.org/xalan" xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="1.0">

  <xsl:output method="xml" encoding="UTF-8" indent="yes" xalan:indent-amount="2" />
  <xsl:param name="plugin.groupId" />
  <xsl:param name="plugin.artifactId" />
  <xsl:param name="plugin.version" />
  <xsl:include href="datamodel2ext.xsl" />

  <xsl:template match="/">
    <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      elementFormDefault="qualified" xmlns:xlink="http://www.w3.org/1999/xlink">
      <xsl:call-template name="schemaAnnotation" />
      <xs:import namespace="http://www.w3.org/1999/xlink" schemaLocation="http://www.w3.org/XML/2008/06/xlink.xsd" />
      <xs:import namespace="http://www.w3.org/XML/1998/namespace" schemaLocation="http://www.w3.org/2001/xml.xsd" />
      <xs:include schemaLocation="mycore-common-datamodel2.xsd" />
      <xsl:apply-templates select="objecttype/xsd" />
      <xsl:apply-templates mode="structure" />
      <xsl:apply-templates mode="metadata" />
      <xsl:apply-templates select="objecttype/metadata/element" mode="metadata" />
    </xs:schema>
  </xsl:template>

  <xsl:template name="schemaAnnotation">
    <xs:annotation>
      <xs:documentation>
        <xsl:choose>
          <xsl:when test="string-length($plugin.groupId)&gt;0">
            <xsl:value-of select="concat('Generated by ',$plugin.groupId,':',$plugin.artifactId,':', $plugin.version)" />
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="'Automatically generated via XSL stylesheet.'" />
          </xsl:otherwise>
        </xsl:choose>
      </xs:documentation>
    </xs:annotation>
  </xsl:template>

  <xsl:template match="xsd">
    <xsl:copy-of select="*" />
  </xsl:template>

  <xsl:template match="objecttype" mode="structure">
      <xs:complexType name="structType">
        <xs:sequence>
          <xsl:if test="@isChild = 'true'">
            <xs:element name="parents" type="parentsType" minOccurs="0" />
          </xsl:if>
          <xsl:if test="@isParent = 'true'">
            <xs:element name="children" type="childrenType" minOccurs="0" />
          </xsl:if>
          <xsl:if test="@hasDerivates = 'true'">
            <xs:element name="derobjects" type="derobjectsType" minOccurs="0" />
          </xsl:if>
        </xs:sequence>
      </xs:complexType>
  </xsl:template>

  <xsl:template match="objecttype" mode="metadata">
      <xs:complexType name="metadataType">
        <xs:all>
          <xsl:for-each select="/objecttype/metadata/element/@name">
            <xs:element>
              <xsl:attribute name="name">
                <xsl:choose>
                  <xsl:when test="../@wrapper">
                    <xsl:value-of select="../@wrapper" />
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="concat('def.',.)" />
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:attribute>
              <xsl:attribute name="type">
                <xsl:choose>
                  <xsl:when test="../@wrapper">
                    <xsl:value-of select="concat(../@wrapper,'Type')" />
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="concat('def.',.,'Type')" />
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:attribute>
              <xsl:choose>
                <xsl:when test="../@required">
                  <xsl:if test="not(../@required = 'true')">
                    <xsl:attribute name="minOccurs">
                      <xsl:value-of select="0" />
                    </xsl:attribute>
                  </xsl:if>
                </xsl:when>
                <xsl:when test="../@minOccurs = 0">
                  <xsl:attribute name="minOccurs">
                    <xsl:value-of select="0" />
                  </xsl:attribute>
                </xsl:when>
              </xsl:choose>
            </xs:element>
          </xsl:for-each>
        </xs:all>
        <xs:attribute ref="xml:lang" use="optional" />
      </xs:complexType>
  </xsl:template>

  <xsl:template match="element" mode="enclosing">
    <xsl:param name="class" />
    <xs:element>
      <xsl:variable name="name">
        <xsl:choose>
          <xsl:when test="@wrapper">
            <xsl:value-of select="@wrapper" />
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="concat('def.',@name)" />
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>

      <xs:complexType>
        <xsl:attribute name="name">
          <xsl:value-of select="concat($name,'Type')" />
        </xsl:attribute>
        <xs:sequence>
          <xs:element>
            <xsl:if test="@maxOccurs!=1">
              <xsl:attribute name="maxOccurs">
                <xsl:value-of select="@maxOccurs" />
              </xsl:attribute>
            </xsl:if>
            <xsl:if test="@minOccurs &gt; 1">
              <xsl:attribute name="minOccurs">
                <xsl:value-of select="@minOccurs" />
              </xsl:attribute>
            </xsl:if>
            <xsl:attribute name="type">
              <xsl:value-of select="concat(@name,'Type')" />
            </xsl:attribute>
            <xsl:attribute name="name">
              <xsl:value-of select="@name" />
            </xsl:attribute>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="class" use="required" type="xs:NCName" fixed="{$class}" />
        <xsl:choose>
          <xsl:when test="@notinherit='ignore'">
            <xs:attribute name="notinherit" type="xs:boolean" />
          </xsl:when>
          <xsl:when test="@notinherit='true'">
            <xs:attribute name="notinherit" type="xs:boolean" use="required" fixed="{@notinherit}" />
          </xsl:when>
          <xsl:when test="@notinherit='false'">
            <xs:attribute name="notinherit" type="xs:boolean" fixed="{@notinherit}" />
          </xsl:when>
          <xsl:when test="not(@notinherit) and @heritable">
            <xs:attribute name="notinherit" type="xs:boolean" fixed="false" />
          </xsl:when>
        </xsl:choose>
        <xsl:choose>
          <xsl:when test="@heritable='ignore'">
            <xs:attribute name="heritable" type="xs:boolean" />
          </xsl:when>
          <xsl:when test="@heritable='true'">
            <xs:attribute name="heritable" type="xs:boolean" use="required" fixed="{@heritable}" />
          </xsl:when>
          <xsl:when test="@heritable='false'">
            <xs:attribute name="heritable" type="xs:boolean" fixed="{@heritable}" />
          </xsl:when>
          <xsl:when test="not(@heritable) and @notinherit">
            <xs:attribute name="heritable" type="xs:boolean" fixed="false" />
          </xsl:when>
        </xsl:choose>
        <xsl:if test="not(@notinherit) and not(@heritable)">
          <xs:attributeGroup ref="noInheritance" />
        </xsl:if>
      </xs:complexType>
  </xsl:template>

  <xsl:template match="element" mode="inner">
    <xsl:param name="class" />
    <xsl:param name="containsText" select="false()" />
    <xsl:param name="complexType" select="''" />
    <xsl:param name="textFormat" select="'xs:string'" />
      <xs:complexType>
        <xsl:attribute name="name">
          <xsl:value-of select="concat(@name, 'Type')" />
        </xsl:attribute>        
        <xsl:choose>
          <xsl:when test="$containsText">
            <xs:simpleContent>
              <xs:extension base="{$textFormat}">
                <xs:attributeGroup ref="{$class}" />
                <xs:attributeGroup ref="notInherited" />
                <xsl:apply-templates select="." mode="types" />
                <xsl:apply-templates select="." mode="sequences" />
              </xs:extension>
            </xs:simpleContent>
          </xsl:when>
          <xsl:otherwise>
            <xsl:copy-of select="$complexType" />
            <xs:attributeGroup ref="{$class}" />
            <xs:attributeGroup ref="notInherited" />
            <xsl:apply-templates select="." mode="types" />
            <xsl:apply-templates select="." mode="sequences" />
          </xsl:otherwise>
        </xsl:choose>
      </xs:complexType>
  </xsl:template>

  <xsl:template match="element[@type='text']" mode="metadata">
    <xsl:apply-templates select="." mode="enclosing">
      <xsl:with-param name="class" select="'MCRMetaLangText'" />
    </xsl:apply-templates>
    <xsl:apply-templates select="." mode="inner">
      <xsl:with-param name="class" select="'MCRMetaLangText'" />
      <xsl:with-param name="containsText" select="true()" />
    </xsl:apply-templates>
  </xsl:template>

  <xsl:template match="element[@type='boolean']" mode="metadata">
    <xsl:apply-templates select="." mode="enclosing">
      <xsl:with-param name="class" select="'MCRMetaBoolean'" />
    </xsl:apply-templates>
    <xsl:apply-templates select="." mode="inner">
      <xsl:with-param name="class" select="'MCRMetaBoolean'" />
      <xsl:with-param name="containsText" select="true()" />
    </xsl:apply-templates>
  </xsl:template>

  <xsl:template match="element[@type='classification']" mode="metadata">
    <xsl:apply-templates select="." mode="enclosing">
      <xsl:with-param name="class" select="'MCRMetaClassification'" />
    </xsl:apply-templates>
    <xsl:apply-templates select="." mode="inner">
      <xsl:with-param name="class" select="'MCRMetaClassification'" />
    </xsl:apply-templates>
  </xsl:template>

  <xsl:template match="element[@type='link']" mode="metadata">
    <xsl:apply-templates select="." mode="enclosing">
      <xsl:with-param name="class" select="'MCRMetaLinkID'" />
    </xsl:apply-templates>
    <xsl:apply-templates select="." mode="inner">
      <xsl:with-param name="class" select="'MCRMetaLinkID'" />
    </xsl:apply-templates>
  </xsl:template>

  <xsl:template match="element[@type='href']" mode="metadata">
    <xsl:apply-templates select="." mode="enclosing">
      <xsl:with-param name="class" select="'MCRMetaLink'" />
    </xsl:apply-templates>
    <xsl:apply-templates select="." mode="inner">
      <xsl:with-param name="class" select="'MCRMetaLink'" />
    </xsl:apply-templates>
  </xsl:template>

  <xsl:template match="element[@type='derlink']" mode="metadata">
    <xsl:apply-templates select="." mode="enclosing">
      <xsl:with-param name="class" select="'MCRMetaDerivateLink'" />
    </xsl:apply-templates>
    <xsl:variable name="innerSchema">
      <xs:sequence>
        <xs:element name="annotation" minOccurs="0" maxOccurs="unbounded">
          <xs:complexType>
            <xs:simpleContent>
              <xs:extension base="xs:string">
                <xs:attribute ref="xml:lang" />
              </xs:extension>
            </xs:simpleContent>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xsl:variable>
    <xsl:apply-templates select="." mode="inner">
      <xsl:with-param name="class" select="'MCRMetaDerivateLink'" />
      <xsl:with-param name="complexType" select="xalan:nodeset($innerSchema)/*" />
    </xsl:apply-templates>
  </xsl:template>

  <xsl:template match="element[@type='date']" mode="metadata">
    <xsl:apply-templates select="." mode="enclosing">
      <xsl:with-param name="class" select="'MCRMetaISO8601Date'" />
    </xsl:apply-templates>
    <xsl:apply-templates select="." mode="inner">
      <xsl:with-param name="class" select="'MCRMetaISO8601Date'" />
      <xsl:with-param name="containsText" select="true()" />
      <xsl:with-param name="textFormat" select="'mycoreDate'" />
    </xsl:apply-templates>
  </xsl:template>

  <xsl:template match="element[@type='number']" mode="metadata">
    <xsl:apply-templates select="." mode="enclosing">
      <xsl:with-param name="class" select="'MCRMetaNumber'" />
    </xsl:apply-templates>
    <xsl:apply-templates select="." mode="inner">
      <xsl:with-param name="class" select="'MCRMetaNumber'" />
      <xsl:with-param name="containsText" select="true()" />
      <xsl:with-param name="textFormat" select="'mycoreNumber'" />
    </xsl:apply-templates>
  </xsl:template>

  <xsl:template match="element[@type='xml']" mode="metadata">
    <xsl:apply-templates select="." mode="enclosing">
      <xsl:with-param name="class" select="'MCRMetaXML'" />
    </xsl:apply-templates>
    <xsl:apply-templates select="." mode="inner">
      <xsl:with-param name="class" select="'MCRMetaXML'" />
      <xsl:with-param name="complexType" select="xs:*" />
    </xsl:apply-templates>
  </xsl:template>

  <xsl:template match="element[@type='historydate']" mode="metadata">
    <xsl:apply-templates select="." mode="enclosing">
      <xsl:with-param name="class" select="'MCRMetaHistoryDate'" />
    </xsl:apply-templates>
    <xsl:variable name="innerSchema">
      <xs:sequence>
        <xs:element maxOccurs="unbounded" minOccurs="1" name="text">
          <xs:complexType>
            <xs:simpleContent>
              <xs:extension base="xs:string">
                <xs:attribute use="optional" ref="xml:lang" />
              </xs:extension>
            </xs:simpleContent>
          </xs:complexType>
        </xs:element>
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="calendar" />
        <xs:element maxOccurs="1" minOccurs="0" type="xs:integer" name="ivon" />
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="von" />
        <xs:element maxOccurs="1" minOccurs="0" type="xs:integer" name="ibis" />
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="bis" />
      </xs:sequence>
    </xsl:variable>
    <xsl:apply-templates select="." mode="inner">
      <xsl:with-param name="class" select="'MCRMetaHistoryDate'" />
      <xsl:with-param name="complexType" select="xalan:nodeset($innerSchema)/*" />
    </xsl:apply-templates>
  </xsl:template>

  <xsl:template match="element[@type='personname']" mode="metadata">
    <xsl:apply-templates select="." mode="enclosing">
      <xsl:with-param name="class" select="'MCRMetaPersonName'" />
    </xsl:apply-templates>
    <xsl:variable name="innerSchema">
      <xs:sequence>
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="firstname" />
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="callname" />
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="fullname" />
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="surname" />
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="academic" />
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="peerage" />
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="numeration" />
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="title" />
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="prefix" />
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="affix" />
      </xs:sequence>
    </xsl:variable>
    <xsl:apply-templates select="." mode="inner">
      <xsl:with-param name="class" select="'MCRMetaPersonName'" />
      <xsl:with-param name="complexType" select="xalan:nodeset($innerSchema)/*" />
    </xsl:apply-templates>
  </xsl:template>

  <xsl:template match="element[@type='address']" mode="metadata">
    <xsl:apply-templates select="." mode="enclosing">
      <xsl:with-param name="class" select="'MCRMetaPersonName'" />
    </xsl:apply-templates>
    <xsl:variable name="innerSchema">
      <xs:sequence>
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="country" />
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="state" />
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="zipcode" />
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="city" />
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="street" />
        <xs:element maxOccurs="1" minOccurs="0" type="xs:string" name="number" />
      </xs:sequence>
    </xsl:variable>
    <xsl:apply-templates select="." mode="inner">
      <xsl:with-param name="class" select="'MCRMetaPersonName'" />
      <xsl:with-param name="complexType" select="xalan:nodeset($innerSchema)/*" />
    </xsl:apply-templates>
  </xsl:template>

  <xsl:template match="element[@type='accessrule']" mode="metadata">
    <xsl:apply-templates select="." mode="enclosing">
      <xsl:with-param name="class" select="'MCRMetaAccessRule'" />
    </xsl:apply-templates>
    <xsl:apply-templates select="." mode="inner">
      <xsl:with-param name="class" select="'MCRMetaAccessRule'" />
      <xsl:with-param name="complexType" select="xs:*" />
    </xsl:apply-templates>
  </xsl:template>

  <xsl:template match="element" mode="types">
    <xsl:choose>
      <xsl:when test="type">
        <xs:attribute name="type" use="required">
          <xs:simpleType>
            <xs:restriction base="xs:string">
              <xsl:for-each select="type/@name">
                <xs:enumeration value="{.}" />
              </xsl:for-each>
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
      </xsl:when>
      <xsl:otherwise>
        <xs:attribute name="type" type="xs:string" />
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template match="element" mode="sequences">
    <xs:attribute name="sequence" type="xs:string" />
  </xsl:template>

</xsl:stylesheet>
